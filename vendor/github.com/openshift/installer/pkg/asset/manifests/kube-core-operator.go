package manifests

import (
	"fmt"
	"strings"

	"github.com/apparentlymart/go-cidr/cidr"
	kubecore "github.com/coreos/tectonic-config/config/kube-core"
	"github.com/ghodss/yaml"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/installconfig"
	"github.com/openshift/installer/pkg/types"
)

const (
	authConfigOIDCClientID        = "tectonic-kubectl"
	authConfigOIDCGroupsClaim     = "groups"
	authConfigOIDCUsernameClaim   = "email"
	networkConfigAdvertiseAddress = "0.0.0.0"
)

// KubeCoreOperator generates the kube-core-operator.yaml files
type KubeCoreOperator struct {
	Config *kubecore.OperatorConfig
	File   *asset.File
}

var _ asset.WritableAsset = (*KubeCoreOperator)(nil)

// Name returns a human friendly name for the operator
func (kco *KubeCoreOperator) Name() string {
	return "Kube Core Operator"
}

// Dependencies returns all of the dependencies directly needed by an
// KubeCoreOperator asset.
func (kco *KubeCoreOperator) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.InstallConfig{},
	}
}

// Generate generates the kube-core-operator-config.yml files
func (kco *KubeCoreOperator) Generate(dependencies asset.Parents) error {
	installConfig := &installconfig.InstallConfig{}
	dependencies.Get(installConfig)

	clusterIP, err := cidr.Host(&installConfig.Config.Networking.ServiceCIDR.IPNet, 10)
	if err != nil {
		return errors.Wrapf(err, "failed to create %s config from InstallConfig", kco.Name())
	}

	kco.Config = &kubecore.OperatorConfig{
		TypeMeta: metav1.TypeMeta{
			APIVersion: kubecore.APIVersion,
			Kind:       kubecore.Kind,
		},
		ClusterConfig: kubecore.ClusterConfig{
			APIServerURL: getAPIServerURL(installConfig.Config),
		},
		AuthConfig: kubecore.AuthConfig{
			OIDCClientID:      authConfigOIDCClientID,
			OIDCIssuerURL:     getOicdIssuerURL(installConfig.Config),
			OIDCGroupsClaim:   authConfigOIDCGroupsClaim,
			OIDCUsernameClaim: authConfigOIDCUsernameClaim,
		},
		DNSConfig: kubecore.DNSConfig{
			ClusterIP: clusterIP.String(),
		},
		CloudProviderConfig: kubecore.CloudProviderConfig{
			CloudConfigPath:      "",
			CloudProviderProfile: k8sCloudProvider(installConfig.Config.Platform),
		},
		RoutingConfig: kubecore.RoutingConfig{
			Subdomain: getBaseAddress(installConfig.Config),
		},
		NetworkConfig: kubecore.NetworkConfig{
			ClusterCIDR:      installConfig.Config.Networking.PodCIDR.String(),
			ServiceCIDR:      installConfig.Config.Networking.ServiceCIDR.String(),
			AdvertiseAddress: networkConfigAdvertiseAddress,
			EtcdServers:      strings.Join(getEtcdServersURLs(installConfig.Config), ","),
		},
	}

	data, err := yaml.Marshal(kco.Config)
	if err != nil {
		return errors.Wrapf(err, "failed to create %s config from InstallConfig", kco.Name())
	}
	kco.File = &asset.File{
		Filename: "kco-config.yaml",
		Data:     data,
	}

	return nil
}

// Files returns the files generated by the asset.
func (kco *KubeCoreOperator) Files() []*asset.File {
	if kco.File != nil {
		return []*asset.File{kco.File}
	}
	return []*asset.File{}
}

func getEtcdServersURLs(ic *types.InstallConfig) []string {
	var urls []string
	for i := 0; i < ic.MasterCount(); i++ {
		urls = append(urls, fmt.Sprintf("https://%s-etcd-%d.%s:2379", ic.ObjectMeta.Name, i, ic.BaseDomain))
	}
	return urls
}

func getOicdIssuerURL(ic *types.InstallConfig) string {
	return fmt.Sprintf("https://%s.%s/identity", ic.ObjectMeta.Name, ic.BaseDomain)
}

func getBaseAddress(ic *types.InstallConfig) string {
	return fmt.Sprintf("%s.%s", ic.ObjectMeta.Name, ic.BaseDomain)
}

// Converts a platform to the cloudProvider that k8s understands
func k8sCloudProvider(platform types.Platform) string {
	if platform.AWS != nil {
		return "aws"
	}
	if platform.Libvirt != nil {
		//return "libvirt"
	}
	return ""
}
